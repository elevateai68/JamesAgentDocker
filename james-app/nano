#!/usr/bin/env python3
"""
James Agency - LangGraph 3-Model Orchestration
Intelligent routing between James (coordinator), Scout (external data), and Trained (domain expert)
"""

from typing import TypedDict, Annotated, Literal
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langchain_ollama import ChatOllama
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
import re
import json

# State management for conversation flow
class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    current_agent: str
    needs_external_data: bool
    needs_domain_expert: bool
    final_response: str
    user_context: str  # For the context input from UI

# Initialize the three models
james_model = ChatOllama(
    model="qwen2.5:7b",
    temperature=0.7,
    base_url="http://localhost:11434"
)

scout_model = ChatOllama(
    model="llama3.2:3b", 
    temperature=0.3,  # Lower temp for more focused routing decisions
    base_url="http://localhost:11434"
)

# For now, trained model uses same as James - will be replaced with fine-tuned model later
trained_model = ChatOllama(
    model="qwen2.5:7b",
    temperature=0.8,
    base_url="http://localhost:11434"
)

def james_coordinator(state: AgentState) -> AgentState:
    """
    James - Main coordinator with personality, makes routing decisions
    """
    
    # Get the last user message
    user_message = None
    for msg in reversed(state["messages"]):
        if isinstance(msg, HumanMessage):
            user_message = msg.content
            break
    
    if not user_message:
        return state
    
    # James's system prompt with personality and routing logic
    james_system = """You are James, a sophisticated AI coordinator with a subtle James Bond-inspired personality. 
    You're charming, efficient, and slightly mysterious. You coordinate between different specialists on your team.

    Your team consists of:
    - Scout: Handles external data retrieval (web searches, APIs, current prices, news, etc.)
    - Trained: Domain expert for specialized knowledge (will be customized per customer)

    ROUTING DECISIONS:
    Analyze the user's request and determine if you need help:

    ROUTE TO SCOUT if the request needs:
    - Current/live data (prices, weather, news)
    - Web searches
    - External API calls
    - Real-time information

    ROUTE TO TRAINED if the request needs:
    - Specialized domain knowledge
    - Expert advice in specific fields
    - Complex reasoning in specialized areas

    HANDLE YOURSELF if:
    - General conversation
    - Basic questions you can answer
    - Coordination between team members

    RESPOND with:
    - If routing: "ROUTE_TO_SCOUT" or "ROUTE_TO_TRAINED" followed by the specific request
    - If handling yourself: Provide the complete response with your charming personality

    Current context: {context}
    User request: {request}
    """.format(context=state.get("user_context", ""), request=user_message)
    
    messages = [SystemMessage(content=james_system), HumanMessage(content=user_message)]
    response = james_model.invoke(messages)
    
    # Parse James's routing decision
    response_content = response.content
    
    if "ROUTE_TO_SCOUT" in response_content:
        state["needs_external_data"] = True
        state["current_agent"] = "scout"
        # Extract the specific request for Scout
        scout_request = response_content.replace("ROUTE_TO_SCOUT", "").strip()
        state["messages"].append(AIMessage(content=f"James routing to Scout: {scout_request}"))
    elif "ROUTE_TO_TRAINED" in response_content:
        state["needs_domain_expert"] = True  
        state["current_agent"] = "trained"
        # Extract the specific request for Trained
        trained_request = response_content.replace("ROUTE_TO_TRAINED", "").strip()
        state["messages"].append(AIMessage(content=f"James routing to Trained: {trained_request}"))
    else:
        # James handles it himself
        state["final_response"] = response_content
        state["current_agent"] = "james_final"
    
    return state

def scout_agent(state: AgentState) -> AgentState:
    """
    Scout - External data retrieval specialist
    """
    
    # Get the routing request from James
    routing_message = None
    for msg in reversed(state["messages"]):
        if isinstance(msg, AIMessage) and "James routing to Scout:" in msg.content:
            routing_message = msg.content.replace("James routing to Scout:", "").strip()
            break
    
    if not routing_message:
        return state
    
    scout_system = """You are Scout, a specialized AI agent focused on external data retrieval and web intelligence.

    Your capabilities include:
    - Web searches for current information
    - API calls for live data (prices, weather, etc.)
    - Finding and retrieving external resources
    - Fact-checking and verification

    For this request, analyze what external data is needed and provide:
    1. The specific approach you would take
    2. What APIs or search methods you'd use
    3. The information gathered (simulate the result for now)

    Request from James: {request}
    
    Respond as Scout with the gathered information, then hand back to James.
    """.format(request=routing_message)
    
    messages = [SystemMessage(content=scout_system), HumanMessage(content=routing_message)]
    response = scout_model.invoke(messages)
    
    # Scout's response goes back to James for final coordination
    state["messages"].append(AIMessage(content=f"Scout report: {response.content}"))
    state["current_agent"] = "james_final"
    state["needs_external_data"] = False
    
    return state

def trained_agent(state: AgentState) -> AgentState:
    """
    Trained - Domain expert (will be customized per deployment)
    """
    
    # Get the routing request from James
    routing_message = None
    for msg in reversed(state["messages"]):
        if isinstance(msg, AIMessage) and "James routing to Trained:" in msg.content:
            routing_message = msg.content.replace("James routing to Trained:", "").strip()
            break
    
    if not routing_message:
        return state
    
    # For now, generic expert. Will be replaced with fine-tuned domain models
    trained_system = """You are the Trained specialist, a domain expert providing specialized knowledge.

    (This will be customized based on the specific deployment - Baptist Minister, Chiropractor, etc.)
    
    For now, provide expert-level analysis and detailed insights on the request.
    
    Request from James: {request}
    
    Provide your expert analysis and recommendations.
    """.format(request=routing_message)
    
    messages = [SystemMessage(content=trained_system), HumanMessage(content=routing_message)]
    response = trained_model.invoke(messages)
    
    # Trained's response goes back to James for final coordination
    state["messages"].append(AIMessage(content=f"Expert analysis: {response.content}"))
    state["current_agent"] = "james_final"
    state["needs_domain_expert"] = False
    
    return state

def james_final_response(state: AgentState) -> AgentState:
    """
    James provides the final coordinated response
    """
    
    # If James already provided a direct response, use that
    if state.get("final_response"):
        return state
    
    # Otherwise, coordinate the specialist responses
    conversation_history = []
    for msg in state["messages"]:
        if isinstance(msg, HumanMessage):
            conversation_history.append(f"User: {msg.content}")
        elif isinstance(msg, AIMessage):
            conversation_history.append(f"System: {msg.content}")
    
    james_final_system = """You are James, providing the final coordinated response to the user.

    Review the conversation and specialist reports, then provide a cohesive, helpful response with your characteristic charm.

    Conversation history:
    {history}

    Provide your final response to the user with your James Bond-inspired personality.
    """.format(history="\n".join(conversation_history))
    
    # Get original user request
    user_message = None
    for msg in state["messages"]:
        if isinstance(msg, HumanMessage):
            user_message = msg.content
            break
    
    messages = [SystemMessage(content=james_final_system), HumanMessage(content=user_message or "")]
    response = james_model.invoke(messages)
    
    state["final_response"] = response.content
    return state

# Define routing logic
def route_decision(state: AgentState) -> Literal["scout", "trained", "james_final"]:
    """Route to the appropriate agent based on James's decision"""
    return state.get("current_agent", "james_final")

# Build the workflow graph
def create_james_workflow():
    """Create the LangGraph workflow for the James system"""
    
    workflow = StateGraph(AgentState)
    
    # Add nodes
    workflow.add_node("james_coordinator", james_coordinator)
    workflow.add_node("scout", scout_agent)
    workflow.add_node("trained", trained_agent)
    workflow.add_node("james_final", james_final_response)
    
    # Define the flow
    workflow.add_edge(START, "james_coordinator")
    
    # Conditional routing from James
    workflow.add_conditional_edges(
        "james_coordinator",
        route_decision,
        {
            "scout": "scout",
            "trained": "trained", 
            "james_final": "james_final"
        }
    )
    
    # Both specialists route back to James for final response
    workflow.add_edge("scout", "james_final")
    workflow.add_edge("trained", "james_final")
    
    # End after final response
    workflow.add_edge("james_final", END)
    
    return workflow.compile()

# Test function
def test_james_system():
    """Test the James system with sample queries"""
    
    app = create_james_workflow()
    
    test_queries = [
        "What's the current Bitcoin price?",  # Should route to Scout
        "Hello James, how are you today?",   # Should handle directly
        "I need help with my church sermon", # Should route to Trained
    ]
    
    for query in test_queries:
        print(f"\n{'='*50}")
        print(f"Testing: {query}")
        print(f"{'='*50}")
        
        initial_state = {
            "messages": [HumanMessage(content=query)],
            "current_agent": "",
            "needs_external_data": False,
            "needs_domain_expert": False,
            "final_response": "",
            "user_context": ""
        }
        
        try:
            result = app.invoke(initial_state)
            print(f"Final Response: {result['final_response']}")
            print(f"Routing Path: {[msg.content for msg in result['messages'] if isinstance(msg, AIMessage)]}")
        except Exception as e:
            print(f"Error: {e}")

if __name__ == "__main__":
    # Test the system
    test_james_system()
